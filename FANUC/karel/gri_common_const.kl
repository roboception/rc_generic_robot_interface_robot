-- File: gri_common_const.kl
-- Common constants for GRI KAREL clients

CONST
  -- Communication Settings
  SERVER_PORT = 10000       -- Port for the GRI server
  CLIENT_TAG = 'C3:'        -- KAREL client tag (e.g., C1:, C3:)
  TIMEOUT_VALUE_MS = 5000   -- Socket timeout in milliseconds
  TIMEOUT_ERR = 2031        -- KAREL IO_STATUS code for timeout

  -- GRI Protocol V2 Constants
  REQ_MAGIC_NUM = 2
  RESP_MAGIC_NUM = 2
  REQ_PROTO_VER = 1
  RESP_PROTO_VER = 1
  REQ_MSG_TOTAL_LEN = 50
  RESP_MSG_TOTAL_LEN = 56

  -- Pose Format
  REQ_POSE_FMT_XYZWPR_CUSTOM = 10 -- MM_WPR_FANUC

  -- GRI Protocol V2 Actions
  REQ_ACTION_UNKNOWN = 0
  REQ_ACTION_STATUS = 1
  REQ_ACTION_TRIGGER_JOB_SYNC = 2
  REQ_ACTION_TRIGGER_JOB_ASYNC = 3
  REQ_ACTION_GET_JOB_STATUS = 4
  REQ_ACTION_GET_NEXT_POSE = 5
  REQ_ACTION_GET_RELATED_POSE = 6
  REQ_ACTION_HEC_INIT = 7
  REQ_ACTION_HEC_SET_POSE = 8
  REQ_ACTION_HEC_CALIBRATE = 9

  -- KAREL Specific Sizes
  KAREL_REAL_SIZE = 4
  KAREL_INT_SIZE = 4
  
  -- Pose Scaling Constants
  POSE_SCALE_FACTOR = 1000000  -- 10^6 scaling factor for int32 pose conversion
  POSE_SCALE_FACTOR_REAL = 1000000.0  -- Real version for calculations

  -- Request Message Structure (Client sends X,Y,Z,W,P,R,R4 as scaled int32)
  REQ_HEADER_LEN = 5
  REQ_NUM_POSE_INTS_SEND = 7  -- Client sends 7 int32s (X,Y,Z,W,P,R,R4) scaled by 10^6
  REQ_POSE_PAYLOAD_LEN = 28 -- REQ_NUM_POSE_INTS_SEND * KAREL_INT_SIZE (7*4)
  NUM_DATA_INTS_TO_SEND = 4
  REQ_DATA_PAYLOAD_LEN = 16 -- NUM_DATA_INTS_TO_SEND * KAREL_INT_SIZE (4*4)

  -- Response Message Structure (Server sends X,Y,Z,Q1,Q2,Q3,Q4 as scaled int32)
  RESP_HEADER_LEN = 5  -- True header (magic, protocol, msg_len, pose_fmt, action)
  RESP_STATUS_LEN = 3  -- Job ID (1) + Error Code (2)
  RESP_HEADER_TOTAL_LEN = 8  -- RESP_HEADER_LEN + RESP_STATUS_LEN (5+3)
  RESP_NUM_POSE_INTS_RECV = 7  -- Server sends 7 int32s (X,Y,Z,Q1,Q2,Q3,Q4) scaled by 10^6
  RESP_POSE_PAYLOAD_LEN = 28 -- RESP_NUM_POSE_INTS_RECV * KAREL_INT_SIZE (7*4)
  RESP_NUM_DATA_INTS_RECV = 5
  RESP_DATA_PAYLOAD_LEN = 20 -- RESP_NUM_DATA_INTS_RECV * KAREL_INT_SIZE (5*4)
  RESP_PADDING_LEN = 0 -- RESP_MSG_TOTAL_LEN - RESP_HEADER_TOTAL_LEN - RESP_POSE_PAYLOAD_LEN - RESP_DATA_PAYLOAD_LEN (56-8-28-20)

  -- GRI Protocol V2 Error Codes
  GRI_ERR_NO_ERROR = 0
  GRI_ERR_UNKNOWN_ERROR = 1
  GRI_ERR_INTERNAL_ERROR = 2
  GRI_ERR_API_NOT_REACHABLE = 3
  GRI_ERR_PIPELINE_NOT_AVAILABLE = 4
  GRI_ERR_INVALID_REQUEST_ERROR = 5
  GRI_ERR_INVALID_REQUEST_LENGTH = 6
  GRI_ERR_INVALID_ACTION = 7
  GRI_ERR_PROCESSING_TIMEOUT = 8
  GRI_ERR_UNKNOWN_PROTOCOL_VERSION = 9
  GRI_ERR_JOB_DOES_NOT_EXIST = 10
  GRI_ERR_JOB_CHANGED = 11
  GRI_ERR_MISCONFIGURED_JOB = 12
  GRI_ERR_NO_POSES_FOUND = 13
  GRI_ERR_NO_ASSOCIATED_OBJECTS = 14
  GRI_ERR_NO_RETURN_SPECIFIED = 15
  GRI_ERR_JOB_STILL_RUNNING = 16
  GRI_ERR_HEC_CONFIG_ERROR = 17
  GRI_ERR_HEC_INIT_ERROR = 18
  GRI_ERR_HEC_SET_POSE_ERROR = 19
  GRI_ERR_HEC_CALIBRATE_ERROR = 20
  GRI_ERR_HEC_INSUFFICIENT_DETECTION = 21
  GRI_ERR_NOT_IMPLEMENTED = 100
  GRI_ERR_API_ERROR = 101
  GRI_ERR_API_RESPONSE_ERROR = 102
  GRI_ERR_WRONG_PROTOCOL_FOR_RETURN = 103

  -- GRI Protocol V2 Job Status Codes (for KAREL)
  JOB_STATUS_UNKNOWN = 0
  JOB_STATUS_INACTIVE = 1
  JOB_STATUS_RUNNING = 2
  JOB_STATUS_DONE = 3
  JOB_STATUS_FAILED = 4

  -- Log prefixes
  LPRE_SYNC = '[TJOB_SYNC] '
  LPRE_ASYNC = '[TJOB_ASYNC] '
  LPRE_GETSTAT = '[GET_STAT] '
  LPRE_GETNEXT = '[GET_NEXT] '
  LPRE_GETREL = '[GET_REL] '
  LPRE_HEC = '[HEC] '
  LPRE_HEC_INIT = '[HEC_INIT] '
  LPRE_HEC_SET = '[HEC_SET] '
  LPRE_HEC_CALIB = '[HEC_CALIB] '

  -- General KAREL status
  SUCCESS_STATUS = 0

-- Function to get job status message string from status code
ROUTINE get_job_status_message(status_code : INTEGER) : STRING
  BEGIN
    SELECT status_code OF
      CASE (JOB_STATUS_UNKNOWN):
        RETURN('UNKNOWN')
      CASE (JOB_STATUS_INACTIVE):
        RETURN('INACTIVE')
      CASE (JOB_STATUS_RUNNING):
        RETURN('RUNNING')
      CASE (JOB_STATUS_DONE):
        RETURN('DONE')
      CASE (JOB_STATUS_FAILED):
        RETURN('FAILED')
      ELSE:
        RETURN('INVALID_STATUS')
    ENDSELECT
  END get_job_status_message

-- Function to get error message string from error code
ROUTINE get_error_message(error_code : INTEGER) : STRING
  BEGIN
    SELECT error_code OF
      CASE (GRI_ERR_NO_ERROR):
        RETURN('NO_ERROR')
      CASE (GRI_ERR_UNKNOWN_ERROR):
        RETURN('UNKNOWN_ERROR')
      CASE (GRI_ERR_INTERNAL_ERROR):
        RETURN('INTERNAL_ERROR')
      CASE (GRI_ERR_API_NOT_REACHABLE):
        RETURN('API_NOT_REACHABLE')
      CASE (GRI_ERR_PIPELINE_NOT_AVAILABLE):
        RETURN('PIPELINE_NOT_AVAILABLE')
      CASE (GRI_ERR_INVALID_REQUEST_ERROR):
        RETURN('INVALID_REQUEST_ERROR')
      CASE (GRI_ERR_INVALID_REQUEST_LENGTH):
        RETURN('INVALID_REQUEST_LENGTH')
      CASE (GRI_ERR_INVALID_ACTION):
        RETURN('INVALID_ACTION')
      CASE (GRI_ERR_PROCESSING_TIMEOUT):
        RETURN('PROCESSING_TIMEOUT')
      CASE (GRI_ERR_UNKNOWN_PROTOCOL_VERSION):
        RETURN('UNKNOWN_PROTOCOL_VERSION')
      CASE (GRI_ERR_JOB_DOES_NOT_EXIST):
        RETURN('JOB_DOES_NOT_EXIST')
      CASE (GRI_ERR_JOB_CHANGED):
        RETURN('JOB_CHANGED')
      CASE (GRI_ERR_MISCONFIGURED_JOB):
        RETURN('MISCONFIGURED_JOB')
      CASE (GRI_ERR_NO_POSES_FOUND):
        RETURN('NO_POSES_FOUND')
      CASE (GRI_ERR_NO_ASSOCIATED_OBJECTS):
        RETURN('NO_ASSOCIATED_OBJECTS')
      CASE (GRI_ERR_NO_RETURN_SPECIFIED):
        RETURN('NO_RETURN_SPECIFIED')
      CASE (GRI_ERR_JOB_STILL_RUNNING):
        RETURN('JOB_STILL_RUNNING')
      CASE (GRI_ERR_HEC_CONFIG_ERROR):
        RETURN('HEC_CONFIG_ERROR')
      CASE (GRI_ERR_HEC_INIT_ERROR):
        RETURN('HEC_INIT_ERROR')
      CASE (GRI_ERR_HEC_SET_POSE_ERROR):
        RETURN('HEC_SET_POSE_ERROR')
      CASE (GRI_ERR_HEC_CALIBRATE_ERROR):
        RETURN('HEC_CALIBRATE_ERROR')
      CASE (GRI_ERR_HEC_INSUFFICIENT_DETECTION):
        RETURN('HEC_INSUFFICIENT_DETECTION')
      CASE (GRI_ERR_NOT_IMPLEMENTED):
        RETURN('NOT_IMPLEMENTED')
      CASE (GRI_ERR_API_ERROR):
        RETURN('API_ERROR')
      CASE (GRI_ERR_API_RESPONSE_ERROR):
        RETURN('API_RESPONSE_ERROR')
      CASE (GRI_ERR_WRONG_PROTOCOL_FOR_RETURN):
        RETURN('WRONG_PROTOCOL_FOR_RETURN')
      ELSE:
        RETURN('UNKNOWN_ERROR_CODE')
    ENDSELECT
  END get_error_message

-- Common routine to build and send request header
ROUTINE send_request_header(action : INTEGER; job_id : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    s_req_hdr_magic     : STRING[1]
    s_req_hdr_proto_ver : STRING[1]
    s_req_hdr_msg_len   : STRING[1]
    s_req_hdr_pose_fmt  : STRING[1]
    s_req_hdr_action    : STRING[1]
    s_req_hdr_job_id    : STRING[1]
    request_hdr_str     : STRING[REQ_HEADER_LEN]
    local_status        : INTEGER
  BEGIN
    local_status = SUCCESS_STATUS
    
    -- Build header
    s_req_hdr_magic     = CHR(REQ_MAGIC_NUM)
    s_req_hdr_proto_ver = CHR(REQ_PROTO_VER)
    s_req_hdr_msg_len   = CHR(REQ_MSG_TOTAL_LEN)
    s_req_hdr_pose_fmt  = CHR(REQ_POSE_FMT_XYZWPR_CUSTOM)
    s_req_hdr_action    = CHR(action)
    
    -- Validate job_id range - fail immediately if invalid
    IF (job_id < 0) OR (job_id > 255) THEN
        WRITE TPDISPLAY(log_prefix, 'ERROR: Job ID ', job_id, ' out of range 0-255. Request aborted!', CR)
        WRITE g_log_file(log_prefix, 'ERROR: Job ID ', job_id, ' out of range 0-255. Request aborted!', CR)
        RETURN(GRI_ERR_INVALID_REQUEST_ERROR)
    ENDIF
    s_req_hdr_job_id    = CHR(job_id)
    request_hdr_str = s_req_hdr_magic + s_req_hdr_proto_ver + s_req_hdr_msg_len + s_req_hdr_pose_fmt + s_req_hdr_action
    
    -- Always-on request header summary (file only)
    WRITE g_log_file(log_prefix, 'SENDING', CR)
    WRITE g_log_file(log_prefix, 'header: magic=', REQ_MAGIC_NUM, ' proto=', REQ_PROTO_VER, ' len=', REQ_MSG_TOTAL_LEN, ' pose_fmt=', REQ_POSE_FMT_XYZWPR_CUSTOM, ' action=', action, ' job_id=', job_id, CR)

    -- Send header
    WRITE g_file_var(request_hdr_str::REQ_HEADER_LEN)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_HDR] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_HDR] St:', local_status, CR)
      RETURN(local_status)
    ENDIF

    -- Send job_id separately (1 byte)
    WRITE g_file_var(s_req_hdr_job_id::1)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_JID] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_JID] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    RETURN(local_status)
  END send_request_header

-- Common routine to send pose data (convert real to scaled int32)
ROUTINE send_pose_data(pose : XYZWPR; log_prefix : STRING) : INTEGER
  VAR
    local_status : INTEGER
    scaled_x, scaled_y, scaled_z : INTEGER
    scaled_w, scaled_p, scaled_r : INTEGER
    scaled_r4 : INTEGER
    b1_i, b2_i, b3_i, b4_i : INTEGER
    npos, t1, t2, t3, t4 : INTEGER
    s_int_byte1 : STRING[1]
    s_int_byte2 : STRING[1]
    s_int_byte3 : STRING[1]
    s_int_byte4 : STRING[1]
    packed_int_str : STRING[KAREL_INT_SIZE]
    dbg_msg : STRING[200]
  BEGIN
    local_status = SUCCESS_STATUS
    
    -- Convert real values to scaled int32 values
    scaled_x = ROUND(pose.X * POSE_SCALE_FACTOR_REAL)
    scaled_y = ROUND(pose.Y * POSE_SCALE_FACTOR_REAL)
    scaled_z = ROUND(pose.Z * POSE_SCALE_FACTOR_REAL)
    scaled_w = ROUND(pose.W * POSE_SCALE_FACTOR_REAL)
    scaled_p = ROUND(pose.P * POSE_SCALE_FACTOR_REAL)
    scaled_r = ROUND(pose.R * POSE_SCALE_FACTOR_REAL)
    scaled_r4 = 0  -- 4th rotation component is 0
    
    -- Always-on request pose summary
    WRITE g_log_file(log_prefix, 'pose: X=', pose.X::7::3, ' Y=', pose.Y::7::3, ' Z=', pose.Z::7::3, ' W=', pose.W::7::3, ' P=', pose.P::7::3, ' R=', pose.R::7::3, CR)

    -- Write X as little-endian 4 bytes (two's complement safe)
    IF scaled_x >= 0 THEN
      b1_i = (scaled_x MOD 256)
      b2_i = ((scaled_x DIV 256) MOD 256)
      b3_i = ((scaled_x DIV 65536) MOD 256)
      b4_i = ((scaled_x DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_x - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PX: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PX] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PX] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Write Y as little-endian 4 bytes (two's complement safe)
    IF scaled_y >= 0 THEN
      b1_i = (scaled_y MOD 256)
      b2_i = ((scaled_y DIV 256) MOD 256)
      b3_i = ((scaled_y DIV 65536) MOD 256)
      b4_i = ((scaled_y DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_y - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PY: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PY] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PY] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Write Z as little-endian 4 bytes (two's complement safe)
    IF scaled_z >= 0 THEN
      b1_i = (scaled_z MOD 256)
      b2_i = ((scaled_z DIV 256) MOD 256)
      b3_i = ((scaled_z DIV 65536) MOD 256)
      b4_i = ((scaled_z DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_z - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PZ: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PZ] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PZ] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Write W as little-endian 4 bytes (two's complement safe)
    IF scaled_w >= 0 THEN
      b1_i = (scaled_w MOD 256)
      b2_i = ((scaled_w DIV 256) MOD 256)
      b3_i = ((scaled_w DIV 65536) MOD 256)
      b4_i = ((scaled_w DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_w - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PW: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PW] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PW] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Write P as little-endian 4 bytes (two's complement safe)
    IF scaled_p >= 0 THEN
      b1_i = (scaled_p MOD 256)
      b2_i = ((scaled_p DIV 256) MOD 256)
      b3_i = ((scaled_p DIV 65536) MOD 256)
      b4_i = ((scaled_p DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_p - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PP: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PP] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PP] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Write R as little-endian 4 bytes (two's complement safe)
    IF scaled_r >= 0 THEN
      b1_i = (scaled_r MOD 256)
      b2_i = ((scaled_r DIV 256) MOD 256)
      b3_i = ((scaled_r DIV 65536) MOD 256)
      b4_i = ((scaled_r DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_r - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PR: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PR] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PR] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Write R4 as little-endian 4 bytes (two's complement safe)
    IF scaled_r4 >= 0 THEN
      b1_i = (scaled_r4 MOD 256)
      b2_i = ((scaled_r4 DIV 256) MOD 256)
      b3_i = ((scaled_r4 DIV 65536) MOD 256)
      b4_i = ((scaled_r4 DIV 16777216) MOD 256)
    ELSE
      npos = -scaled_r4 - 1
      t1 = (npos MOD 256)
      t2 = ((npos DIV 256) MOD 256)
      t3 = ((npos DIV 65536) MOD 256)
      t4 = ((npos DIV 16777216) MOD 256)
      b1_i = 255 - t1
      b2_i = 255 - t2
      b3_i = 255 - t3
      b4_i = 255 - t4
    ENDIF
    s_int_byte1 = CHR(b1_i)
    s_int_byte2 = CHR(b2_i)
    s_int_byte3 = CHR(b3_i)
    s_int_byte4 = CHR(b4_i)
    packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES OUT] PR4: ', b1_i, ' ', b2_i, ' ', b3_i, ' ', b4_i, CR)
    ENDIF
    WRITE g_file_var(packed_int_str::KAREL_INT_SIZE) -- 4th rotation component
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_SND_PR4] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_SND_PR4] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    RETURN(local_status)
  END send_pose_data

-- Common routine to send data integers
ROUTINE send_data_integers(data_array : ARRAY[*] OF INTEGER; array_size : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    i                  : INTEGER
    req_data_int_val   : INTEGER
    b1_i               : INTEGER
    b2_i               : INTEGER
    b3_i               : INTEGER
    b4_i               : INTEGER
    npos, t1, t2, t3, t4 : INTEGER
    s_int_byte1        : STRING[1]
    s_int_byte2        : STRING[1]
    s_int_byte3        : STRING[1]
    s_int_byte4        : STRING[1]
    req_packed_int_str : STRING[KAREL_INT_SIZE]
    local_status       : INTEGER
  BEGIN
    local_status = SUCCESS_STATUS
    
    FOR i = 1 TO array_size DO
      req_data_int_val = data_array[i]
      -- Write data int as little-endian 4 bytes (two's complement safe)
      IF req_data_int_val >= 0 THEN
        b1_i = (req_data_int_val MOD 256)
        b2_i = ((req_data_int_val DIV 256) MOD 256)
        b3_i = ((req_data_int_val DIV 65536) MOD 256)
        b4_i = ((req_data_int_val DIV 16777216) MOD 256)
      ELSE
        npos = -req_data_int_val - 1
        t1 = (npos MOD 256)
        t2 = ((npos DIV 256) MOD 256)
        t3 = ((npos DIV 65536) MOD 256)
        t4 = ((npos DIV 16777216) MOD 256)
        b1_i = 255 - t1
        b2_i = 255 - t2
        b3_i = 255 - t3
        b4_i = 255 - t4
      ENDIF
      s_int_byte1 = CHR(b1_i)
      s_int_byte2 = CHR(b2_i)
      s_int_byte3 = CHR(b3_i)
      s_int_byte4 = CHR(b4_i)
      req_packed_int_str = s_int_byte1 + s_int_byte2 + s_int_byte3 + s_int_byte4
      
      WRITE g_file_var(req_packed_int_str::KAREL_INT_SIZE)
      local_status = IO_STATUS(g_file_var)
      IF local_status <> SUCCESS_STATUS THEN
        WRITE TPDISPLAY(log_prefix, '[ERR_SND_ADAT] INT[', i, '] St:', local_status, CR)
        WRITE g_log_file(log_prefix, '[ERR_SND_ADAT] INT[', i, '] St:', local_status, CR)
        RETURN(local_status)
      ENDIF
    ENDFOR
    
    RETURN(local_status)
  END send_data_integers

-- Common routine to read and validate response header
ROUTINE read_response_header(expected_action : INTEGER; expected_job_id : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    response_hdr_str    : STRING[RESP_HEADER_TOTAL_LEN]
    resp_hdr_magic      : INTEGER
    resp_hdr_proto_ver  : INTEGER
    resp_hdr_msg_len    : INTEGER
    resp_hdr_pose_fmt   : INTEGER
    resp_hdr_action     : INTEGER
    resp_hdr_job_id     : INTEGER
    resp_hdr_err_code   : INTEGER
    
    b_resp_hdr_valid    : BOOLEAN
    b_resp_magic_ok     : BOOLEAN
    b_resp_proto_ok     : BOOLEAN
    b_resp_len_ok       : BOOLEAN
    b_hdr_read_len_ok   : BOOLEAN
    b_resp_pose_fmt_ok  : BOOLEAN 
    b_resp_action_ok    : BOOLEAN
    b_resp_job_id_ok    : BOOLEAN 
    b_resp_err_code_ok  : BOOLEAN
    
    local_status        : INTEGER
  BEGIN
    local_status = SUCCESS_STATUS
    
    -- Read response header
    read g_file_var(response_hdr_str::RESP_HEADER_TOTAL_LEN)
    local_status = IO_STATUS(g_file_var)
    IF local_status = TIMEOUT_ERR THEN
      WRITE TPDISPLAY(log_prefix, '[TIMEOUT_RECV_HDR]', CR)
      WRITE g_log_file(log_prefix, '[TIMEOUT_RECV_HDR]', CR)
      RETURN(local_status)
    ENDIF 
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_RECV_HDR] St:', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_RECV_HDR] St:', local_status, CR)
      RETURN(local_status)
    ENDIF
    
    -- Check header length
    b_hdr_read_len_ok = (STR_LEN(response_hdr_str) = RESP_HEADER_TOTAL_LEN)
    IF NOT b_hdr_read_len_ok THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_RECV_HDR_LEN] Len:', STR_LEN(response_hdr_str), ' Exp:', RESP_HEADER_TOTAL_LEN, CR)
      WRITE g_log_file(log_prefix, '[ERR_RECV_HDR_LEN] Len:', STR_LEN(response_hdr_str), ' Exp:', RESP_HEADER_TOTAL_LEN, CR)
      RETURN(-1) -- Return error code
    ENDIF
    
    -- Parse header fields
    resp_hdr_magic     = ORD(SUB_STR(response_hdr_str, 1, 1), 1)
    resp_hdr_proto_ver = ORD(SUB_STR(response_hdr_str, 2, 1), 1)
    resp_hdr_msg_len   = ORD(SUB_STR(response_hdr_str, 3, 1), 1)
    resp_hdr_pose_fmt  = ORD(SUB_STR(response_hdr_str, 4, 1), 1)
    resp_hdr_action    = ORD(SUB_STR(response_hdr_str, 5, 1), 1)
    resp_hdr_job_id    = ORD(SUB_STR(response_hdr_str, 6, 1), 1)
    -- Parse 16-bit signed error code (2 bytes, little endian)
    resp_hdr_err_code  = ORD(SUB_STR(response_hdr_str, 7, 1), 1) + (ORD(SUB_STR(response_hdr_str, 8, 1), 1) * 256)
    -- Convert to signed 16-bit if needed (handle negative values)
    IF resp_hdr_err_code > 32767 THEN
      resp_hdr_err_code = resp_hdr_err_code - 65536
    ENDIF

    -- Validate header fields
    b_resp_magic_ok    = (resp_hdr_magic = RESP_MAGIC_NUM)
    b_resp_proto_ok    = (resp_hdr_proto_ver = RESP_PROTO_VER)
    b_resp_len_ok      = (resp_hdr_msg_len = RESP_MSG_TOTAL_LEN)
    b_resp_pose_fmt_ok = (resp_hdr_pose_fmt = REQ_POSE_FMT_XYZWPR_CUSTOM) 
    b_resp_action_ok   = (resp_hdr_action = expected_action) 
    b_resp_job_id_ok   = (resp_hdr_job_id = (expected_job_id MOD 256))
    b_resp_err_code_ok = (resp_hdr_err_code = GRI_ERR_NO_ERROR)
      
    b_resp_hdr_valid = b_resp_magic_ok AND b_resp_proto_ok AND b_resp_len_ok AND b_resp_pose_fmt_ok AND b_resp_action_ok AND b_resp_job_id_ok AND b_resp_err_code_ok

    IF NOT b_resp_hdr_valid THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_RESP_HDR_INVALID]', CR)
      WRITE g_log_file(log_prefix, '[ERR_RESP_HDR_INVALID]', CR) 
      WRITE TPDISPLAY('MGC_OK:', b_resp_magic_ok, ' PRT_OK:', b_resp_proto_ok, ' LEN_OK:', b_resp_len_ok, CR)
      WRITE g_log_file('MGC_OK:', b_resp_magic_ok, ' PRT_OK:', b_resp_proto_ok, ' LEN_OK:', b_resp_len_ok, CR)
      WRITE TPDISPLAY('FMT_OK:', b_resp_pose_fmt_ok, ' ACT_OK:', b_resp_action_ok, ' JID_OK:', b_resp_job_id_ok, ' ERR_OK:', b_resp_err_code_ok, CR)
      WRITE g_log_file('FMT_OK:', b_resp_pose_fmt_ok, ' ACT_OK:', b_resp_action_ok, ' JID_OK:', b_resp_job_id_ok, ' ERR_OK:', b_resp_err_code_ok, CR)
      WRITE TPDISPLAY('Got: MGC=', resp_hdr_magic, '(E:', RESP_MAGIC_NUM, '),PRT=', resp_hdr_proto_ver, '(E:', RESP_PROTO_VER, '),LEN=', resp_hdr_msg_len, '(E:', RESP_MSG_TOTAL_LEN, ')', CR)
      WRITE g_log_file('Got: MGC=', resp_hdr_magic, '(E:', RESP_MAGIC_NUM, '),PRT=', resp_hdr_proto_ver, '(E:', RESP_PROTO_VER, '),LEN=', resp_hdr_msg_len, '(E:', RESP_MSG_TOTAL_LEN, ')', CR)
      WRITE TPDISPLAY('FMT=', resp_hdr_pose_fmt, '(E:', REQ_POSE_FMT_XYZWPR_CUSTOM, '),ACT=', resp_hdr_action, '(E:', expected_action, ')', CR)
      WRITE g_log_file('FMT=', resp_hdr_pose_fmt, '(E:', REQ_POSE_FMT_XYZWPR_CUSTOM, '),ACT=', resp_hdr_action, '(E:', expected_action, ')', CR)
      WRITE TPDISPLAY('JID=', resp_hdr_job_id, '(E:', (expected_job_id MOD 256), '),ERR=', resp_hdr_err_code, '(E:', GRI_ERR_NO_ERROR, ')', CR)
      WRITE g_log_file('JID=', resp_hdr_job_id, '(E:', (expected_job_id MOD 256), '),ERR=', resp_hdr_err_code, '(E:', GRI_ERR_NO_ERROR, ')', CR)
      RETURN(-1) -- Return error code
    ENDIF

    RETURN(local_status)
  END read_response_header

-- Common routine to read response data integers  
ROUTINE read_response_data_integers(data_array : ARRAY[*] OF INTEGER; array_size : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    i            : INTEGER
    local_status : INTEGER
    packed_str   : STRING[KAREL_INT_SIZE]
    b1           : INTEGER
    b2           : INTEGER
    b3           : INTEGER
    b4           : INTEGER
    signed_val   : INTEGER
    dbg_msg      : STRING[120]
  BEGIN
    local_status = SUCCESS_STATUS
    
    FOR i = 1 TO array_size DO
      read g_file_var(packed_str::KAREL_INT_SIZE)
      local_status = IO_STATUS(g_file_var)
      IF local_status <> SUCCESS_STATUS THEN
        WRITE TPDISPLAY(log_prefix, '[ERR_RECV_ADAT] INT[', i, '] St:', local_status, CR)
        WRITE g_log_file(log_prefix, '[ERR_RECV_ADAT] INT[', i, '] St:', local_status, CR)
        RETURN(local_status)
      ENDIF
      -- Assemble little-endian signed int32
      b1 = ORD(SUB_STR(packed_str, 1, 1), 1)
      b2 = ORD(SUB_STR(packed_str, 2, 1), 1)
      b3 = ORD(SUB_STR(packed_str, 3, 1), 1)
      b4 = ORD(SUB_STR(packed_str, 4, 1), 1)
      IF b4 < 128 THEN
        signed_val = b1 + (b2 * 256) + (b3 * 65536) + (b4 * 16777216)
      ELSE
        signed_val = -(((255 - b1) + ((255 - b2) * 256) + ((255 - b3) * 65536) + ((255 - b4) * 16777216)) + 1)
      ENDIF
      data_array[i] = signed_val

      IF g_debug_bytes_enabled THEN
        WRITE g_log_file(log_prefix, 'DEBUG [BYTES] data int: idx=', i, ' ', b1, ' ', b2, ' ', b3, ' ', b4, CR)
        WRITE g_log_file(log_prefix, 'DEBUG data int: idx=', i, ' value=', data_array[i], CR)
      ENDIF
    ENDFOR
    
    RETURN(local_status)
  END read_response_data_integers

-- Common routine to read 7 pose int32s and convert to reals with error checking
ROUTINE read_response_pose_7_reals(pose_reals : ARRAY[*] OF REAL; log_prefix : STRING) : INTEGER
  VAR
    i            : INTEGER
    local_status : INTEGER
    scaled_int   : INTEGER
    packed_str   : STRING[KAREL_INT_SIZE]
    b1           : INTEGER
    b2           : INTEGER
    b3           : INTEGER
    b4           : INTEGER
    dbg_msg      : STRING[120]
  BEGIN
    local_status = SUCCESS_STATUS
    
    FOR i = 1 TO 7 DO
      read g_file_var(packed_str::KAREL_INT_SIZE)
      local_status = IO_STATUS(g_file_var)
      IF local_status <> SUCCESS_STATUS THEN
        WRITE TPDISPLAY(log_prefix, '[ERR_RECV_POSE] Int[', i, '] St:', local_status, CR)
        WRITE g_log_file(log_prefix, '[ERR_RECV_POSE] Int[', i, '] St:', local_status, CR)
        RETURN(local_status)
      ENDIF
      -- Assemble little-endian signed int32
      b1 = ORD(SUB_STR(packed_str, 1, 1), 1)
      b2 = ORD(SUB_STR(packed_str, 2, 1), 1)
      b3 = ORD(SUB_STR(packed_str, 3, 1), 1)
      b4 = ORD(SUB_STR(packed_str, 4, 1), 1)
      IF b4 < 128 THEN
        scaled_int = b1 + (b2 * 256) + (b3 * 65536) + (b4 * 16777216)
      ELSE
        scaled_int = -(((255 - b1) + ((255 - b2) * 256) + ((255 - b3) * 65536) + ((255 - b4) * 16777216)) + 1)
      ENDIF
      IF g_debug_bytes_enabled THEN
        WRITE g_log_file(log_prefix, 'DEBUG [BYTES] pose int: idx=', i, ' ', b1, ' ', b2, ' ', b3, ' ', b4, CR)
        WRITE g_log_file(log_prefix, 'DEBUG pose int: idx=', i, ' raw=', scaled_int, ' real=', (scaled_int / POSE_SCALE_FACTOR_REAL), CR)
      ENDIF
      -- Convert scaled int32 back to real
      pose_reals[i] = scaled_int / POSE_SCALE_FACTOR_REAL
    ENDFOR
    
    RETURN(local_status)
  END read_response_pose_7_reals

-- Common routine to read response header and return server error code (for HEC functions)
-- Returns: server error code (or negative value for communication errors)
ROUTINE read_response_header_with_error_code(expected_action : INTEGER; expected_job_id : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    response_hdr_str    : STRING[RESP_HEADER_TOTAL_LEN]
    resp_hdr_magic      : INTEGER
    resp_hdr_proto_ver  : INTEGER
    resp_hdr_msg_len    : INTEGER
    resp_hdr_pose_fmt   : INTEGER
    resp_hdr_action     : INTEGER
    resp_hdr_job_id     : INTEGER
    server_error_code   : INTEGER
    
    b_resp_hdr_valid    : BOOLEAN
    b_resp_magic_ok     : BOOLEAN
    b_resp_proto_ok     : BOOLEAN
    b_resp_len_ok       : BOOLEAN
    b_resp_action_ok    : BOOLEAN
    b_resp_job_id_ok    : BOOLEAN
    i_hdr_byte          : INTEGER
    dbg_hdr_msg         : STRING[200]
    
    local_status        : INTEGER
  BEGIN
    local_status = SUCCESS_STATUS
    server_error_code = GRI_ERR_UNKNOWN_ERROR
    
    -- Read response header
    read g_file_var(response_hdr_str::RESP_HEADER_TOTAL_LEN)
    local_status = IO_STATUS(g_file_var)
    IF local_status <> SUCCESS_STATUS THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_RECV_HDR] Status: ', local_status, CR)
      WRITE g_log_file(log_prefix, '[ERR_RECV_HDR] Status: ', local_status, CR)
      RETURN(-1)  -- Return negative value for communication errors
    ENDIF
    
    -- RECEIVING block and header bytes (debug)
    WRITE g_log_file(log_prefix, 'RECEIVING', CR)
    IF g_debug_bytes_enabled THEN
      WRITE g_log_file(log_prefix, 'DEBUG [BYTES] header:')
      FOR i_hdr_byte = 1 TO RESP_HEADER_TOTAL_LEN DO
        WRITE g_log_file(' ', ORD(SUB_STR(response_hdr_str, i_hdr_byte, 1), 1))
      ENDFOR
      WRITE g_log_file(CR)
    ENDIF
    
    -- Parse response header
    resp_hdr_magic = ORD(SUB_STR(response_hdr_str, 1, 1), 1)
    resp_hdr_proto_ver = ORD(SUB_STR(response_hdr_str, 2, 1), 1)
    resp_hdr_msg_len = ORD(SUB_STR(response_hdr_str, 3, 1), 1)
    resp_hdr_pose_fmt = ORD(SUB_STR(response_hdr_str, 4, 1), 1)
    resp_hdr_action = ORD(SUB_STR(response_hdr_str, 5, 1), 1)
    resp_hdr_job_id = ORD(SUB_STR(response_hdr_str, 6, 1), 1)
    -- Parse 16-bit signed error code (2 bytes, little endian)
    server_error_code = ORD(SUB_STR(response_hdr_str, 7, 1), 1) + (ORD(SUB_STR(response_hdr_str, 8, 1), 1) * 256)
    -- Convert to signed 16-bit if needed (handle negative values)
    IF server_error_code > 32767 THEN
      server_error_code = server_error_code - 65536
    ENDIF
    
    -- Only to file (no TPDISPLAY) to avoid long pendant lines
    WRITE g_log_file(log_prefix, 'header: magic=', resp_hdr_magic, ' proto=', resp_hdr_proto_ver, ' len=', resp_hdr_msg_len, CR)
    WRITE g_log_file(log_prefix, 'header: pose_fmt=', resp_hdr_pose_fmt, ' action=', resp_hdr_action, ' job_id=', resp_hdr_job_id, ' error_code=', server_error_code, CR)
    
    -- Validate response header (but allow non-zero error codes)
    b_resp_magic_ok = (resp_hdr_magic = RESP_MAGIC_NUM)
    b_resp_proto_ok = (resp_hdr_proto_ver = RESP_PROTO_VER)
    b_resp_len_ok = (resp_hdr_msg_len = RESP_MSG_TOTAL_LEN)
    b_resp_action_ok = (resp_hdr_action = expected_action)
    -- Only validate job_id if there's no server error (error responses may have different job_id)
    IF server_error_code = GRI_ERR_NO_ERROR THEN
      b_resp_job_id_ok = (resp_hdr_job_id = expected_job_id)
    ELSE
      b_resp_job_id_ok = TRUE  -- Skip job_id validation for error responses
    ENDIF
    b_resp_hdr_valid = b_resp_magic_ok AND b_resp_proto_ok AND b_resp_len_ok AND b_resp_action_ok AND b_resp_job_id_ok
    
    IF NOT b_resp_hdr_valid THEN
      WRITE TPDISPLAY(log_prefix, '[ERR_RESP_HDR_INVALID]', CR)
      WRITE g_log_file(log_prefix, '[ERR_RESP_HDR_INVALID]', CR)
      RETURN(-2)  -- Return negative value for header validation errors
    ENDIF
    
    RETURN(server_error_code)  -- Return actual server error code
  END read_response_header_with_error_code


-- ENDCONST -- Not strictly needed if it's the end of file and only consts, but good practice. 

-- Additional helper routines for eliminating code duplication

-- Helper routine to consume entire response payload for error cases
ROUTINE consume_response_payload(log_prefix : STRING) : INTEGER
  VAR
    i : INTEGER
    local_status : INTEGER
    dummy_int : INTEGER
    dummy_byte : STRING[1]
  BEGIN
    local_status = SUCCESS_STATUS
    
    -- Consume pose int32s
    FOR i = 1 TO RESP_NUM_POSE_INTS_RECV DO
      read g_file_var(dummy_int::KAREL_INT_SIZE)
      local_status = IO_STATUS(g_file_var)
      IF local_status <> SUCCESS_STATUS THEN
        WRITE TPDISPLAY(log_prefix, '[ERR_CONSUME_POSE] Int[', i, '] St:', local_status, CR)
        WRITE g_log_file(log_prefix, '[ERR_CONSUME_POSE] Int[', i, '] St:', local_status, CR)
        RETURN(local_status)
      ENDIF
    ENDFOR
    
    -- Consume data integers
    FOR i = 1 TO RESP_NUM_DATA_INTS_RECV DO
      read g_file_var(dummy_int::KAREL_INT_SIZE)
      local_status = IO_STATUS(g_file_var)
      IF local_status <> SUCCESS_STATUS THEN
        WRITE TPDISPLAY(log_prefix, '[ERR_CONSUME_DATA] Int[', i, '] St:', local_status, CR)
        WRITE g_log_file(log_prefix, '[ERR_CONSUME_DATA] Int[', i, '] St:', local_status, CR)
        RETURN(local_status)
      ENDIF
    ENDFOR
    
    -- Consume padding if any
    IF RESP_PADDING_LEN > 0 THEN
      FOR i = 1 TO RESP_PADDING_LEN DO
        read g_file_var(dummy_byte::1)
        local_status = IO_STATUS(g_file_var)
        IF local_status <> SUCCESS_STATUS THEN
          WRITE TPDISPLAY(log_prefix, '[ERR_CONSUME_PAD] Byte[', i, '] St:', local_status, CR)
          WRITE g_log_file(log_prefix, '[ERR_CONSUME_PAD] Byte[', i, '] St:', local_status, CR)
          RETURN(local_status)
        ENDIF
      ENDFOR
    ENDIF
    
    RETURN(local_status)
  END consume_response_payload

-- Helper routine to read pose from response and convert to XYZWPR format
ROUTINE read_response_pose_to_xyzwpr(pose_result : XYZWPR; current_pose : XYZWPR; log_prefix : STRING) : INTEGER
  VAR
    pose_reals : ARRAY[7] OF REAL
    local_status : INTEGER
  BEGIN
    local_status = read_response_pose_7_reals(pose_reals, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(local_status)
    ENDIF
    
    -- Convert reals to XYZWPR format
    pose_result.X = pose_reals[1]
    pose_result.Y = pose_reals[2]
    pose_result.Z = pose_reals[3]
    pose_result.W = pose_reals[4]
    pose_result.P = pose_reals[5]
    pose_result.R = pose_reals[6]
    -- Use current robot configuration for new pose
    pose_result.config_data = current_pose.config_data
    
    -- Log received pose
    WRITE TPDISPLAY(log_prefix, 'Received Pose:', CR)
    WRITE g_log_file(log_prefix, 'Received Pose:', CR)
    WRITE TPDISPLAY('X=', pose_result.X::7::3, ', Y=', pose_result.Y::7::3, ', Z=', pose_result.Z::7::3, CR)
    WRITE g_log_file('X=', pose_result.X::7::3, ', Y=', pose_result.Y::7::3, ', Z=', pose_result.Z::7::3, CR)
    WRITE TPDISPLAY('W=', pose_result.W::7::3, ', P=', pose_result.P::7::3, ', R=', pose_result.R::7::3, CR)
    WRITE g_log_file('W=', pose_result.W::7::3, ', P=', pose_result.P::7::3, ', R=', pose_result.R::7::3, CR)
    
    RETURN(local_status)
  END read_response_pose_to_xyzwpr

-- Helper routine for standard request sending (zero pose + zero data)
ROUTINE send_request_with_auto_pose(action : INTEGER; job_id : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    current_pose : XYZWPR
    zero_data : ARRAY[NUM_DATA_INTS_TO_SEND] OF INTEGER
    local_status : INTEGER
    i : INTEGER
  BEGIN
    -- Initialize data ints to zero
    FOR i = 1 TO NUM_DATA_INTS_TO_SEND DO
      zero_data[i] = 0
    ENDFOR
    
    -- Get current robot pose once (safe for most actions)
    -- Note: status integers passed as 0 ignore detailed status
    current_pose = CURPOS(0, 0)
    
    -- Send request using existing helpers
    local_status = send_request_header(action, job_id, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN RETURN(local_status); ENDIF
    
    local_status = send_pose_data(current_pose, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN RETURN(local_status); ENDIF
    
    local_status = send_data_integers(zero_data, NUM_DATA_INTS_TO_SEND, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN RETURN(local_status); ENDIF
    
    RETURN(local_status)
  END send_request_with_auto_pose

-- Helper routine to log raw response bytes for debugging
ROUTINE log_raw_response_bytes(log_prefix : STRING) : INTEGER
  VAR
    i : INTEGER
    local_status : INTEGER
    raw_byte : STRING[1]
    debug_msg : STRING[200]
  BEGIN
    local_status = SUCCESS_STATUS
    IF g_debug_bytes_enabled THEN
      debug_msg = 'DEBUG [RAW] Response bytes: '
      -- Read and log first 20 bytes of response for debugging
      FOR i = 1 TO 20 DO
        read g_file_var(raw_byte::1)
        local_status = IO_STATUS(g_file_var)
        IF local_status <> SUCCESS_STATUS THEN
          WRITE g_log_file(log_prefix, '[ERR_DEBUG_RAW] Byte[', i, '] St:', local_status, CR)
          RETURN(local_status)
        ENDIF
        debug_msg = debug_msg + CHR(ORD(raw_byte, 1)) + ' '
      ENDFOR
      WRITE g_log_file(log_prefix, debug_msg, CR)
    ENDIF
    RETURN(local_status)
  END log_raw_response_bytes

-- Helper routine for full GRI communication with error handling
ROUTINE gri_communicate_with_pose_result(action : INTEGER; job_id : INTEGER; result_pose : XYZWPR; rem_primary : INTEGER; rem_related : INTEGER; current_pose : XYZWPR; log_prefix : STRING) : INTEGER
  VAR
    local_status : INTEGER
    server_error : INTEGER
    response_data : ARRAY[RESP_NUM_DATA_INTS_RECV] OF INTEGER
  BEGIN
    -- Send standard request with auto pose
    local_status = send_request_with_auto_pose(action, job_id, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Read response with custom header validation for error tolerance
    server_error = read_response_header_with_error_code(action, job_id, log_prefix)
    IF server_error < 0 THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Handle different server responses
    IF server_error = GRI_ERR_NO_ERROR THEN
      -- Success: Read pose and data
      local_status = read_response_pose_to_xyzwpr(result_pose, current_pose, log_prefix)
      IF local_status <> SUCCESS_STATUS THEN RETURN(GRI_ERR_INTERNAL_ERROR); ENDIF
      
      local_status = read_response_data_integers(response_data, RESP_NUM_DATA_INTS_RECV, log_prefix)
      IF local_status <> SUCCESS_STATUS THEN RETURN(GRI_ERR_INTERNAL_ERROR); ENDIF
      
      rem_primary = response_data[1]
      rem_related = response_data[2]
      WRITE TPDISPLAY('RemPrim=', rem_primary, ', RemRel=', rem_related, ', D3=', response_data[3], ', D4=', response_data[4], ', D5=', response_data[5], CR)
      WRITE g_log_file('RemPrim=', rem_primary, ', RemRel=', rem_related, ', D3=', response_data[3], ', D4=', response_data[4], ', D5=', response_data[5], CR)
      WRITE TPDISPLAY(log_prefix, 'Success', CR)
      WRITE g_log_file(log_prefix, 'Success', CR)
      
    ELSE
      -- Error: Consume payload and return server error
      WRITE TPDISPLAY(log_prefix, 'Server Error: ', server_error, ' - ', get_error_message(server_error), CR)
      WRITE g_log_file(log_prefix, 'Server Error: ', server_error, ' - ', get_error_message(server_error), CR)
      local_status = consume_response_payload(log_prefix)
      IF local_status <> SUCCESS_STATUS THEN RETURN(GRI_ERR_INTERNAL_ERROR); ENDIF
    ENDIF
    
    RETURN(server_error)
  END gri_communicate_with_pose_result 

-- Helper routine for status-returning functions (like get_job_status)
ROUTINE gri_communicate_for_status(action : INTEGER; job_id : INTEGER; log_prefix : STRING) : INTEGER
  VAR
    local_status : INTEGER
    server_error : INTEGER
    dummy_pose_reals : ARRAY[7] OF REAL
    response_data : ARRAY[RESP_NUM_DATA_INTS_RECV] OF INTEGER
  BEGIN
    -- Send standard request with auto pose
    local_status = send_request_with_auto_pose(action, job_id, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(JOB_STATUS_UNKNOWN)
    ENDIF
    
    -- Read response with custom header validation for error tolerance
    server_error = read_response_header_with_error_code(action, job_id, log_prefix)
    IF server_error < 0 THEN
      RETURN(JOB_STATUS_UNKNOWN)
    ENDIF
    
    -- Handle different server responses
    IF server_error = GRI_ERR_NO_ERROR THEN
      -- Success: Read pose payload (not used for status but must be consumed)
      local_status = read_response_pose_7_reals(dummy_pose_reals, log_prefix)
      IF local_status <> SUCCESS_STATUS THEN RETURN(JOB_STATUS_UNKNOWN); ENDIF
      
      -- Read data integers to get the actual status
      local_status = read_response_data_integers(response_data, RESP_NUM_DATA_INTS_RECV, log_prefix)
      IF local_status <> SUCCESS_STATUS THEN RETURN(JOB_STATUS_UNKNOWN); ENDIF
      
      WRITE TPDISPLAY(log_prefix, 'Success - Status: ', response_data[1], ' (', get_job_status_message(response_data[1]), ')', CR)
      WRITE g_log_file(log_prefix, 'Success - Status: ', response_data[1], ' (', get_job_status_message(response_data[1]), ')', CR)
      
      RETURN(response_data[1])  -- Return the actual job status
      
    ELSE
      -- Error: Consume payload and return unknown status
      WRITE TPDISPLAY(log_prefix, 'Server Error: ', server_error, ' - ', get_error_message(server_error), CR)
      WRITE g_log_file(log_prefix, 'Server Error: ', server_error, ' - ', get_error_message(server_error), CR)
      local_status = consume_response_payload(log_prefix)
      IF local_status <> SUCCESS_STATUS THEN RETURN(JOB_STATUS_UNKNOWN); ENDIF
      
      RETURN(JOB_STATUS_UNKNOWN)
    ENDIF
  END gri_communicate_for_status 

-- Helper routine for confirmation functions (like HEC routines)
ROUTINE gri_communicate_for_confirmation(action : INTEGER; job_id : INTEGER; pose_to_send : XYZWPR; data_to_send : ARRAY[*] OF INTEGER; log_prefix : STRING) : INTEGER
  VAR
    local_status : INTEGER
    server_error : INTEGER
    dummy_pose_reals : ARRAY[7] OF REAL
    dummy_data_ints : ARRAY[RESP_NUM_DATA_INTS_RECV] OF INTEGER
    pose_to_write : XYZWPR
    curpose_dummy : XYZWPR
  BEGIN
    -- Determine which pose to send: use provided pose only for HEC_SET_POSE; otherwise auto CURPOS
    IF action = REQ_ACTION_HEC_SET_POSE THEN
      pose_to_write = pose_to_send
    ELSE
      curpose_dummy = CURPOS(0, 0)
      pose_to_write = curpose_dummy
    ENDIF

    -- Use modular routine to build and send request header
    local_status = send_request_header(action, job_id, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Use modular routine to send pose data
    local_status = send_pose_data(pose_to_write, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Use modular routine to send data integers
    local_status = send_data_integers(data_to_send, NUM_DATA_INTS_TO_SEND, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Use modular routine to read response header and extract server error code
    server_error = read_response_header_with_error_code(action, job_id, log_prefix)
    IF server_error < 0 THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Consume response payload using modular routines
    local_status = read_response_pose_7_reals(dummy_pose_reals, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    -- Use modular routine to read dummy data integers
    local_status = read_response_data_integers(dummy_data_ints, RESP_NUM_DATA_INTS_RECV, log_prefix)
    IF local_status <> SUCCESS_STATUS THEN
      RETURN(GRI_ERR_INTERNAL_ERROR)
    ENDIF
    
    IF server_error = GRI_ERR_NO_ERROR THEN
      WRITE TPDISPLAY(log_prefix, 'Success', CR)
      WRITE g_log_file(log_prefix, 'Success', CR)
    ELSE
      WRITE TPDISPLAY(log_prefix, 'ERROR ', server_error, ' - ', get_error_message(server_error), CR)
      WRITE g_log_file(log_prefix, 'ERROR ', server_error, ' - ', get_error_message(server_error), CR)
    ENDIF
    
    RETURN(server_error)
  END gri_communicate_for_confirmation 